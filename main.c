#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <syslog.h>
#include <time.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <malloc.h>
#include <stdlib.h>

#include "libutils.h"
#include "mtypes.h"

//lhl
#include <linux/serial.h>
#include <sys/ioctl.h>
#include "../include/atmel_gpio.h"


int OpenCom485(unsigned short baud,unsigned char *par,unsigned char stopb,unsigned char bits,unsigned char ComPortNo)
{
	///lhl
	#define RTS485			0x542D
	#define TIOCGRS485      0x542E
	#define TIOCSRS485      0x542F

	struct serial_rs485 rs485conf;
	int 	rs485gpio;

	struct termios old_termi,new_termi;
	int baud_lnx=0;
	unsigned char tmp[128];
	int ComPort;
	memset(tmp,0,128);


	if(ComPortNo == 0)
		return 0;
	sprintf((char *)tmp,"/dev/ttyS%d",ComPortNo);
    ComPort = open((char *)tmp, O_RDWR  | O_NOCTTY |O_NDELAY);/* 打开串口文件 */
    if( ComPort<0 )
    {
    	fprintf(stderr, "open the serial port fail! errno is: %d\n", errno);
    	return 0; /*打开串口失败*/
    }
    if ( tcgetattr( ComPort, &old_termi) != 0) /*存储原来的设置*/
    {
    	fprintf(stderr, "get the terminal parameter error when set baudrate! errno is: %d\n", errno);
    	//获取终端相关参数时出错
    	return 0;
    }

    bzero(&new_termi,sizeof(new_termi));    				//将结构体清零
    new_termi.c_cflag|= (CLOCAL|CREAD); 					//忽略调制解调器状态行，接收使能
    new_termi.c_lflag&=~(ICANON|ECHO|ECHOE);				//选择为原始输入模式
    new_termi.c_oflag&=~OPOST; 								//选择为原始输出模式
    new_termi.c_cc[VTIME] = 1; 								/*设置超时时间为0.5 s*/
    new_termi.c_cc[VMIN] = 0;								/*最少返回的字节数是 7*/
    new_termi.c_cflag &= ~CSIZE;
    //new_termi.c_iflag &= ~INPCK;    // Enable parity checking
    new_termi.c_iflag &=~ ISTRIP;
    switch(baud)
    {
    	case 1200:
    		baud_lnx = B1200;
    		break;
    	case 2400:
    		baud_lnx = B2400;
    		break;
    	case 4800:
    		baud_lnx = B4800;
    		break;
    	case 9600:
    		baud_lnx = B9600;
    		break;
    	case 19200:
    		baud_lnx = B19200;
    		break;
    	case 38400:
    		baud_lnx = B38400;
    		break;
    	default:
    		baud_lnx = B2400;
    		break;
    }

    switch( bits )
	{
		case 5:
			new_termi.c_cflag |= CS5;
			break;
		case 6:
			new_termi.c_cflag |= CS6;
			break;
		case 7:
			new_termi.c_cflag |= CS7;
			break;
		case 8:
			new_termi.c_cflag |= CS8;
			break;
		default:
			new_termi.c_cflag |= CS8;
			break;
	}

    if(strncmp((char *)par,"even",4)==0)//设置奇偶校验为偶校验
    {
		//new_termi.c_iflag |= (INPCK | ISTRIP);
    	new_termi.c_cflag |= PARENB;
    	new_termi.c_cflag &= ~PARODD;
    }
    else if(strncmp((char *)par,"odd",3)==0)  //设置奇偶校验为奇校验
	{
		new_termi.c_cflag |= PARENB;
		new_termi.c_cflag |= PARODD;
		//new_termi.c_iflag |= (INPCK | ISTRIP);
	}
    else
    {
    	new_termi.c_cflag &= ~PARENB; 	//设置奇偶校验为无校验
    	//new_termi.c_iflag &=~ ISTRIP;
    }

	if(stopb==1)//停止位
	{
		new_termi.c_cflag&= ~CSTOPB; //设置停止位为:一位停止位
	}
	else if(stopb==2)
	{
		new_termi.c_cflag |= CSTOPB; //设置停止位为:二位停止位
	}
	else
	{
		new_termi.c_cflag&= ~CSTOPB; //设置停止位为:一位停止位
	}

	cfsetispeed(&new_termi, baud_lnx); 							/* 设置输入拨特率 */
    cfsetospeed(&new_termi, baud_lnx); 							/* 设置输出拨特率 */

    tcflush(ComPort, TCIOFLUSH); 								/* 刷新输入输出流 */
    //阻塞：
    //fcntl(ComPort,F_SETFL,0);
    //非阻塞：
    fcntl(ComPort,F_SETFL,FNDELAY);
    if(tcsetattr(ComPort,TCSANOW,&new_termi)!= 0)				/* 激活串口配置 */
    {
    	fprintf(stderr, "Set serial port parameter error!\n");
    	return 0;
    }

    //lhl
 	/* Enable RS485 mode: */
 	rs485conf.flags |= SER_RS485_ENABLED;

 	/* Set logical level for RTS pin equal to 1 when sending: */
 //	rs485conf.flags |= SER_RS485_RTS_ON_SEND;
 //	/* or, set logical level for RTS pin equal to 0 when sending: */
 	rs485conf.flags &= ~(SER_RS485_RTS_ON_SEND);

 	/* Set logical level for RTS pin equal to 1 after sending: */
 	rs485conf.flags |= SER_RS485_RTS_AFTER_SEND;
 	/* or, set logical level for RTS pin equal to 0 after sending: */
 //	rs485conf.flags &= ~(SER_RS485_RTS_AFTER_SEND);

 	if (ioctl (ComPort, TIOCSRS485, &rs485conf) < 0) {
 		fprintf(stderr,"ioctl TIOCSRS485 error\n");
 	}

 //	if (comport==S4851)
 //		rs485gpio=AT91_PIN_PC1;		//上海485I：AT91_PIN_PC1， 485II：AT91_PIN_PA7 ，这里要根据不同的口进行不同的设置，需修改
 //	else if (comport==S4852)
 //		rs485gpio=AT91_PIN_PA7;
 //	else


 	rs485gpio=AT91_PIN_PC1;
 	if (ioctl (ComPort, RTS485, &rs485gpio) < 0) {
 		/* Error handling. See errno. */
 		fprintf(stderr,"ioctl RTS485 error\n");
 	}
    return ComPort;
}
//接收字符串
#define RECVLEN 1024
INT8U RecvBuf[RECVLEN];

unsigned char ReceiveFromCarr(int ComPort,unsigned char *str)
{
	int rec_head,rec_tail,rec_step,DataLen;
	INT16U RecvHead, RecvTail;
	time_t oldtime=0;
	time_t newtime=0;
	INT16U tmptail=0;
	INT8U TmpBuf[256];
	int i,j,len=0;
	memset(TmpBuf,0,256);
	rec_head=rec_tail= rec_step = DataLen =0;
	RecvHead = RecvTail = 0;

	usleep(300*1000);
	len = read(ComPort,TmpBuf,256);
	if (len>0)
	{
		for(j=0;j<15;j++)
		{
			usleep(20*1000);	//20ms
//			fprintf(stderr, "j=%d: ", j);//test
			for(i=0;i<len;i++)
			{
				fprintf(stderr, "%02x ", TmpBuf[i]);//test
				RecvBuf[RecvHead]=TmpBuf[i];
				RecvHead = (RecvHead+1)%RECVLEN;
			}
//			fprintf(stderr, "\n");//test

//			fprintf(stderr,"step=%d head=%d tail=%d len=%d\n",rec_step,RecvHead,RecvTail,DataLen);
			if (rec_step==0)
			{
				while (RecvTail != RecvHead)
				{
					if(RecvBuf[RecvTail] == 0x68)
					{
						rec_step = 1;
						break;
					}else {
						RecvTail = (RecvTail+1)%RECVLEN;
					}
				}
			}
			if (rec_step==1)
			{
				if(((RecvHead - RecvTail+RECVLEN)%RECVLEN)>=3)
				{
					tmptail=RecvTail;
					tmptail = (tmptail+1)%RECVLEN;
					DataLen = RecvBuf[tmptail];
					tmptail = (tmptail+1)%RECVLEN;
					DataLen |= (RecvBuf[tmptail]<<8);
					if (DataLen !=0)
					{
						rec_step = 2;
						oldtime = time(NULL);
					}else
					{
						RecvTail = (RecvTail+1)%RECVLEN;
						rec_step = 0;
					}
				}
			}
			if (rec_step==2)
			{
				if(((RecvHead - RecvTail+RECVLEN)%RECVLEN)>=DataLen)
				{
					if (RecvBuf[(RecvTail+DataLen-1)%RECVLEN] == 0x16)
					{
						//fprintf(stderr,"\nReceiveFromCarr OK: len = %d\n",DataLen);
						for(i=0; i<DataLen; i++)
						{
							str[i] = RecvBuf[RecvTail];
							RecvTail = (RecvTail+1)%RECVLEN;
						//	fprintf(stderr,"%02x ", str[i]);
						}
						rec_step = 0;
						return DataLen;
					}else {
						RecvTail = (RecvTail+1)%RECVLEN;
						rec_step = 0;
					}
				}else
				{
					newtime = time(NULL);
					if ((newtime-oldtime)> 2)
					{
						RecvTail = (RecvTail+1)%RECVLEN;
						rec_step = 0;
					}
				}
			}
//			len = read(ComPort,TmpBuf,256);
		}
	}
	return 0;
}

INT8U getCS3762(INT8U* buf, const INT16U len)
{
	INT8U i, cs=0;

	for (i=0; i<len; i++)
	{
		cs = (cs + buf[i])%256;
	}
	return cs;
}

INT8S isValid3762(INT8U* recvBuf, const INT16U recvLen)
{
	INT16U len;
	len = (recvBuf[2]<<8) + recvBuf[1];

	if ((recvBuf[0]==0x68) && (len==recvLen) && (recvBuf[recvLen-1]==0x16) &&
			recvBuf[recvLen-2]==getCS3762(&recvBuf[3], recvLen-5))
	{
		return 0;
	}
	return -1;
}

int main(int argc, char *argv[])
{
	if(argc < 2)
	{
		fprintf(stderr,"param 2 ");
		return EXIT_SUCCESS;
	}
	int comport=atoi(argv[1]);
	int	fd = 0;
	fd = OpenCom485(9600,(INT8U*)"even",1,8,comport);
	if(fd<=0)
	{
		fprintf(stderr,"打开串口失败\n");
		return EXIT_SUCCESS;
	}

	TmS currTime;
	tmget(&currTime);
	INT8U lastMin = currTime.Minute;

	INT8U isReadreprot = 0;
	INT8U step = 0;
	INT8U mpcount = 0;

	INT16S SendLen=0, RecvLen=0,WriteLen=0;
	INT8U SendBuff[256], RecvBuff[256];

	fprintf(stderr,"\n start............\n");
	while(1)
	{

		tmget(&currTime);
		SendLen=0;
		RecvLen=0;
		WriteLen=0;
		memset(&SendBuff[0], 0, 256);
		memset(&RecvBuff[0], 0, 256);

//		usleep(500000);

#if 0
		if(isReadreprot == 0)
		{
			//AFN03-F10   ：本地通讯模块运行信息
			/*
			INT8U buf03f10[56] = {
									0x68, 0x38, 0x00, 0x81, 0x01, 0x00, 0x40, 0x00, 0x00, 0x01,
									0x03, 0x02, 0x01, 0x41, 0x36, 0x00, 0x01, 0x00, 0x00, 0x3c,
									0x23, 0x00, 0xd2, 0x00, 0x80, 0x00, 0xf0, 0x55, 0x44, 0x33,
									0x44, 0x11, 0x00, 0xff, 0xff, 0x00, 0x02, 0x21, 0x03, 0x13,
									0x21, 0x03, 0x13, 0x53, 0x45, 0x54, 0x52, 0x18, 0x05, 0x13,
									0x25, 0x00, 0x00, 0x00, 0x04, 0x16
								};
								*/
			INT8U buf03f10[56] = {
					  0x68, 0x38, 0x00, 0x81, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00
					, 0x03, 0x02, 0x01, 0x41, 0x36, 0x00, 0x01, 0x00, 0x00, 0x3C
					, 0x23, 0x00, 0xD2, 0x00, 0x80, 0x00, 0xF0, 0x55, 0x44, 0x33
					, 0x44, 0x11, 0x00, 0xFF, 0xFF, 0x00, 0x02, 0x21, 0x03, 0x13
					, 0x21, 0x03, 0x13, 0x53, 0x45, 0x54, 0x52, 0x18, 0x05, 0x13
					, 0x25, 0x00, 0x00, 0x00, 0x03, 0x16
								};
			memcpy(SendBuff,buf03f10,56);
			WriteLen = 56;
			isReadreprot = 1;
			fprintf(stderr,"\n  AFN03-F10   ：本地通讯模块运行信息");


			fprintf(stderr,"\nS[%d] ",WriteLen);
			int i;
			for(i = 0;i < WriteLen;i++)
			{
				fprintf(stderr,"%02x ",SendBuff[i]);
			}
			fprintf(stderr,"\n");

			SendLen  = write(fd,SendBuff,WriteLen);

			fprintf(stderr,"-----SendLen = %d\n",SendLen);

			sleep(1);
			continue;

		}
#endif
		if((currTime.Minute == 0)&&(lastMin!=currTime.Minute))
		{
			fprintf(stderr,"\n 6-F5  (2个随机，有对应的“最近十次事件记录”的标志位置1)主动上送终端 \n");
			INT8U buf06f5[54] = {
									0x68, 0x36, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
									0x06, 0x10, 0x00, 0x01, 0x02, 0x24, 0xfe, 0xfe, 0xfe, 0xfe,
									0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x68, 0x91, 0x14,
									0x34, 0x48, 0x33, 0x37, 0x33, 0x33, 0x33, 0x33, 0x35, 0x33,
									0x33, 0x34, 0x33, 0x33, 0x33, 0x33, 0xdd, 0x34, 0x34, 0xdd,
									0x0a, 0x16, 0x21, 0x16
								};
			memcpy(SendBuff,buf06f5,54);
			WriteLen = 54;

			fprintf(stderr,"\nS[%d] ",WriteLen);
			int i;
			for(i = 0;i < WriteLen;i++)
			{
				fprintf(stderr,"%02x ",SendBuff[i]);
			}
			fprintf(stderr,"\n");

			SendLen  = write(fd,SendBuff,WriteLen);

			fprintf(stderr,"-----SendLen = %d\n",SendLen);
			lastMin=currTime.Minute;
//			sleep(1);
			continue;

		}



		if((currTime.Minute == 30)&&(lastMin!=currTime.Minute))
		{
			fprintf(stderr,"\n 通信单元->终端    主动上报状态字（1个随机的、无对应事件记录标志置1） \n");
			INT8U buf06f51[53] = {
								  0x68 ,0x35 ,0x00 ,0xc1 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01
								 ,0x06 ,0x10 ,0x00 ,0x01 ,0x02 ,0x23 ,0xfe ,0xfe ,0xfe ,0xfe
								 ,0x68 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x68 ,0x91 ,0x13
								 ,0x34 ,0x48 ,0x33 ,0x37 ,0x35 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33
								 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0xdd ,0x32 ,0xdd ,0xd2
								 ,0x16 ,0xb0 ,0x16
								};
			memcpy(SendBuff,buf06f51,53);
						WriteLen = 53;


			fprintf(stderr,"\nS[%d] ",WriteLen);
			int i;
			for(i = 0;i < WriteLen;i++)
			{
				fprintf(stderr,"%02x ",SendBuff[i]);
			}
			fprintf(stderr,"\n");

			SendLen  = write(fd,SendBuff,WriteLen);

			fprintf(stderr,"-----SendLen = %d\n",SendLen);
			lastMin=currTime.Minute;

//			sleep(1);
			continue;

		}
		RecvLen = ReceiveFromCarr(fd,RecvBuff);

		if(RecvLen <= 0)
		{
			continue;
		}

		fprintf(stderr,"\nR[%d] ",RecvLen);
		int i;
		for(i = 0;i < RecvLen;i++)
		{
			fprintf(stderr,"%02x ",RecvBuff[i]);
		}


		if (isValid3762(&RecvBuff[0], RecvLen) == -1)	//校验通过
		{
			fprintf(stderr,"\n非正常3762报文");
			sleep(1);
			continue;
		}
		if((RecvBuff[10] == 0x00)&&(RecvBuff[11] == 0x01))
		{
			fprintf(stderr,"\n收到确认");
			continue;
		}

#if 0
		if((RecvBuff[10] == 0x10)&&(RecvBuff[11] == 0x01))
		{
			if(mpcount==0)
			{
				INT8U buf1001[19] = {
						0x68 ,0x13 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x05,
						0x10 ,0x01 ,0x00 ,0x00 ,0x00 ,0xf8 ,0x07 ,0x96 ,0x16
											};
				memcpy(SendBuff,buf1001,19);
				WriteLen = 19;
				fprintf(stderr,"\n 查询从节点数量 = 0 ");
			}
			if(mpcount==1)
			{
				INT8U buf1002[19] = {
						0x68 ,0x13 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x07 ,
						0x10 ,0x01 ,0x00 ,0x01 ,0x00 ,0xf8 ,0x07 ,0x99 ,0x16
											};
				memcpy(SendBuff,buf1002,19);
				WriteLen = 19;
				fprintf(stderr,"\n 查询从节点数量 = 1 ");
			}
		}
		if((RecvBuff[10] == 0x11)&&(RecvBuff[11] == 0x01))
		{
			INT8U buf0102[21] = {
						0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
						0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
						0x16
							};
				memcpy(SendBuff,buf0102,21);
				WriteLen = 21;
				fprintf(stderr,"\n  ------添加从节点!------- ");
				mpcount = 1;
		}
		if((RecvBuff[10] == 0x10)&&(RecvBuff[11] == 0x02))
		{
			INT8U buf10012[26] = {
					0x68 ,0x1a ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x08 ,
					0x10 ,0x02 ,0x00 ,0x01 ,0x00 ,0x01 ,0x24 ,0x02 ,0x00 ,0x00 ,
					0x00 ,0x00 ,0x00 ,0x10 ,0xd3 ,0x16
							};
				memcpy(SendBuff,buf10012,26);
				WriteLen = 26;
				fprintf(stderr,"\n  查询从节点信息 afn=10, f2 ");

		}
		if((RecvBuff[10] == 0x01)&&(RecvBuff[11] == 0x02))
		{

			INT8U buf0102[21] = {
					0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
					0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
					0x16
								};
			memcpy(SendBuff,buf0102,21);
			WriteLen = 21;
			fprintf(stderr,"\n  AFN01-F2 ");
			mpcount = 1;

		}
		if((RecvBuff[10] == 0x12)&&(RecvBuff[11] == 0x01))
		{
			INT8U buf0102[21] = {
					0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
					0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
					0x16
								};
			memcpy(SendBuff,buf0102,21);
			WriteLen = 21;
			fprintf(stderr,"\n  重启抄读 ");
		}
		if((RecvBuff[10] == 0x12)&&(RecvBuff[11] == 0x02))
		{
			INT8U buf0102[21] = {
					0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
					0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
					0x16
								};
			memcpy(SendBuff,buf0102,21);
			WriteLen = 21;
			fprintf(stderr,"\n  暂停抄读 ");
		}
		if((RecvBuff[10] == 0x12)&&(RecvBuff[11] == 0x04))
		{
			INT8U buf0102[21] = {
					0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
					0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
					0x16
								};
			memcpy(SendBuff,buf0102,21);
			WriteLen = 21;
			fprintf(stderr,"\n  恢复抄读 ");
		}
		if((RecvBuff[10] == 0x03)&&(RecvBuff[11] == 0x02))
		{
			//AFN03-F10   ：本地通讯模块运行信息
			/*
			INT8U buf03f10[56] = {
									0x68, 0x38, 0x00, 0x81, 0x01, 0x00, 0x40, 0x00, 0x00, 0x01,
									0x03, 0x02, 0x01, 0x41, 0x36, 0x00, 0x01, 0x00, 0x00, 0x3c,
									0x23, 0x00, 0xd2, 0x00, 0x80, 0x00, 0xf0, 0x55, 0x44, 0x33,
									0x44, 0x11, 0x00, 0xff, 0xff, 0x00, 0x02, 0x21, 0x03, 0x13,
									0x21, 0x03, 0x13, 0x53, 0x45, 0x54, 0x52, 0x18, 0x05, 0x13,
									0x25, 0x00, 0x00, 0x00, 0x04, 0x16
								};
								*/
			INT8U buf03f10[56] = {
					  0x68, 0x38, 0x00, 0x81, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00
					, 0x03, 0x02, 0x01, 0x41, 0x36, 0x00, 0x01, 0x00, 0x00, 0x3C
					, 0x23, 0x00, 0xD2, 0x00, 0x80, 0x00, 0xF0, 0x55, 0x44, 0x33
					, 0x44, 0x11, 0x00, 0xFF, 0xFF, 0x00, 0x02, 0x21, 0x03, 0x13
					, 0x21, 0x03, 0x13, 0x53, 0x45, 0x54, 0x52, 0x18, 0x05, 0x13
					, 0x25, 0x00, 0x00, 0x00, 0x03, 0x16
								};
			memcpy(SendBuff,buf03f10,56);
			WriteLen = 56;
			if(isReadreprot == 0)
				isReadreprot = 1;
			fprintf(stderr,"\n  AFN03-F10   ：本地通讯模块运行信息");
		}
		if((RecvBuff[10] == 0x03)&&(RecvBuff[11] == 0x08))
		{
			if(isReadreprot == 1)
			{
				//  AFN03-F4： 查询主节点地址
				INT8U buf03f41[21] = {
										0x68, 0x15, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
										0x03, 0x08, 0x00, 0x55, 0x44, 0x33, 0x44, 0x11, 0x00, 0xaf, 0x16
									};
				memcpy(SendBuff,buf03f41,21);
				WriteLen = 21;
				isReadreprot = 2;
				fprintf(stderr,"\n  AFN03-F4： 查询主节点地址---------1");
			}
			if(isReadreprot == 3)
			{
				//  AFN03-F4： 查询主节点地址
				INT8U buf03f42[21] = {
										0x68, 0x15, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
										0x03, 0x08, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x16
									};
				memcpy(SendBuff,buf03f42,21);
				WriteLen = 21;
				fprintf(stderr,"\n  AFN03-F4： 查询主节点地址--------------32");
			}
		}
		if((RecvBuff[10] == 0x05)&&(RecvBuff[11] == 0x01))
		{
			// AFN05-F1 ：设置载波主节点地if(step==1)址
			INT8U buf05f1[21] = {
									0x68, 0x15, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
									0x00, 0x01, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x81, 0x16
								};
			memcpy(SendBuff,buf05f1,21);
			WriteLen = 21;
			if(isReadreprot == 2)
				isReadreprot = 3;
			fprintf(stderr,"\n  AFN05-F1 ：设置载波主节点地址");
		}

		if((RecvBuff[22] == 0x13)&&(RecvBuff[23] == 0x01))
		{
			INT8U flag = 0;
			if((RecvBuff[39] == 0x36)&&(RecvBuff[40] == 0x48)&&(RecvBuff[41] == 0x33)&&(RecvBuff[42] == 0x37))
			{
				fprintf(stderr,"\n  04001513		复位主动上报状态字");
				// AFN05-F1 ：设置载波主节点地址
				INT8U buf04001513[47] = {
						  0x68 ,0x2f ,0x00 ,0x81 ,0x04 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0c
						 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x32 ,0x00 ,0x00 ,0x00
						 ,0x00 ,0x10 ,0x13 ,0x01 ,0x00 ,0x00 ,0x00 ,0x02 ,0x10 ,0xfe
						 ,0xfe ,0xfe ,0xfe ,0x68 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00
						 ,0x68 ,0x94 ,0x00 ,0x8a ,0x16 ,0x41 ,0x16
									};
				memcpy(SendBuff,buf04001513,47);
				WriteLen = 47;
			}


			if((step==3)&&(RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x48)&&(RecvBuff[41] == 0x33)&&(RecvBuff[42] == 0x37))
			{
				fprintf(stderr,"\n   04001501   主动上报状态字");

				INT8U buf04001501[67] = {
						  0x68 ,0x43 ,0x00 ,0x81 ,0x04 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0d
						 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x32 ,0x00 ,0x00 ,0x00
						 ,0x00 ,0x10 ,0x13 ,0x01 ,0x00 ,0x00 ,0x00 ,0x02 ,0x24 ,0xfe
						 ,0xfe ,0xfe ,0xfe ,0x68 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00
						 ,0x68 ,0x91 ,0x14 ,0x34 ,0x48 ,0x33 ,0x37 ,0x37 ,0x33 ,0x3b
						 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0xdd
						 ,0x32 ,0x34 ,0xdd ,0x11 ,0x16 ,0x64 ,0x16
									};
				memcpy(SendBuff,buf04001501,67);
				WriteLen = 67;
				step = 4;
				flag = 1;
			}

			//34 33 35 44 （01 00 02 11） 11020001：B相欠压总次数
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x33)&&(RecvBuff[41] == 0x35)&&(RecvBuff[42] == 0x44))
			{
				fprintf(stderr,"\n  34 33 35 44 （01 00 02 11） 11020001：B相欠压总次数");
				// AFN05-F1 ：设置载波主节点地址
				INT8U buf11020001[54] = {
						0x68, 0x36, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05,
						0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x17, 0xfe,
						0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						0x68, 0x91, 0x07, 0x34, 0x33, 0x35, 0x44, 0x33, 0x33, 0x34,
						0x08, 0x16, 0x3d, 0x16
									};
				memcpy(SendBuff,buf11020001,54);
				WriteLen = 54;
			}

			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x34)&&(RecvBuff[41] == 0x35)&&(RecvBuff[42] == 0x44))
			{
				fprintf(stderr,"\n 11020101 :B相欠压记录1");

				INT8U buf11020101[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x34, 0x35, 0x44, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x46, 0x42, 0x16, 0xB5, 0x16
									};
				memcpy(SendBuff,buf11020101,57);
				WriteLen = 57;
			}
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x58)&&(RecvBuff[41] == 0x35)&&(RecvBuff[42] == 0x44))
			{
				fprintf(stderr,"\n 11022501 :B相欠压记录2");

				INT8U buf11022501[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x58, 0x35, 0x44, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x22, 0x42, 0x16, 0xB5, 0x16
									};
				memcpy(SendBuff,buf11022501,57);
				WriteLen = 57;
			}




			//34 33 36 4d  （01 00 03 1A）1a030001 :C相断流次数
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x33)&&(RecvBuff[41] == 0x36)&&(RecvBuff[42] == 0x4d))
			{
				fprintf(stderr,"\n 1a030001：C相断流次数");

				INT8U buf1a030001[54] = {
						0x68, 0x36, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07,
						0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x17, 0xfe,
						0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						0x68, 0x91, 0x07, 0x34, 0x33, 0x36, 0x4d, 0x33, 0x33, 0x34,
						0x12, 0x16, 0x53, 0x16
									};
				memcpy(SendBuff,buf1a030001,54);
				WriteLen = 54;
			}

			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x34)&&(RecvBuff[41] == 0x36)&&(RecvBuff[42] == 0x4d))
			{
				fprintf(stderr,"\n 1a030101 :C相断流次数1");

				INT8U buf1a030101[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x34, 0x36, 0x4d, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x46, 0x4c, 0x16, 0xc9, 0x16
									};
				memcpy(SendBuff,buf1a030101,57);
				WriteLen = 57;
			}
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x54)&&(RecvBuff[41] == 0x36)&&(RecvBuff[42] == 0x4d))
			{
				fprintf(stderr,"\n 1a032101 :C相断流次数2");

				INT8U buf1a032101[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x54, 0x36, 0x4d, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x26, 0x4c, 0x16, 0xc9, 0x16
									};
				memcpy(SendBuff,buf1a032101,57);
				WriteLen = 57;
			}





			//18010001	A相失流
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x33)&&(RecvBuff[41] == 0x34)&&(RecvBuff[42] == 0x4B))
			{
				fprintf(stderr,"\n 18010001	A相失流");

				INT8U buf1a030001[54] = {
						0x68, 0x36, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07,
						0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x17, 0xfe,
						0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						0x68, 0x91, 0x07, 0x34, 0x33, 0x34, 0x4b, 0x33, 0x33, 0x34,
						0x0e, 0x16, 0x4b, 0x16
									};
				memcpy(SendBuff,buf1a030001,54);
				WriteLen = 54;
			}

			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x34)&&(RecvBuff[41] == 0x34)&&(RecvBuff[42] == 0x4b))
			{
				fprintf(stderr,"\n 18010101	A相失流1");

				INT8U buf1a030101[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x34, 0x34, 0x4b, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x46, 0x48, 0x16, 0xc1, 0x16
									};
				memcpy(SendBuff,buf1a030101,57);
				WriteLen = 57;
			}
			if((RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x54)&&(RecvBuff[41] == 0x34)&&(RecvBuff[42] == 0x4b))
			{
				fprintf(stderr,"\n 18012101	A相失流2");

				INT8U buf1a032101[57] = {
						 0x68, 0x39, 0x00, 0x81, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06,
						 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
						 0x00, 0x10, 0x13, 0x01, 0x00, 0x00, 0x00, 0x02, 0x1a, 0xfe,
						 0xfe, 0xfe, 0xfe, 0x68, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00,
						 0x68, 0x91, 0x0A, 0x34, 0x34, 0x54, 0x4b, 0x45, 0x67, 0x44,
						 0x55, 0x45, 0x26, 0x48, 0x16, 0xc1, 0x16
									};
				memcpy(SendBuff,buf1a032101,57);
				WriteLen = 57;
			}

			if((RecvBuff[39] == 0x36)&&(RecvBuff[40] == 0x48)&&(RecvBuff[41] == 0x33)&&(RecvBuff[42] == 0x37))
			{
				fprintf(stderr,"\n 通信单元应答复位命令 ");

				INT8U buf1a032101[47] = {
						0x68 ,0x2f ,0x00 ,0x81 ,0x04 ,0x00 ,0x00 ,0x00 ,0x00 ,0x09 ,
						0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x32 ,0x00 ,0x00 ,0x00 ,
						0x00 ,0x10 ,0x13 ,0x01 ,0x00 ,0x00 ,0x00 ,0x02 ,0x10 ,0xfe ,
						0xfe ,0xfe ,0xfe ,0x68 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,
						0x68 ,0x94 ,0x00 ,0x8a ,0x16 ,0x3e ,0x16
									};
				memcpy(SendBuff,buf1a032101,47);
				WriteLen = 47;
			}
			if((flag != 1)&&(RecvBuff[39] == 0x34)&&(RecvBuff[40] == 0x48)&&(RecvBuff[41] == 0x33)&&(RecvBuff[42] == 0x37))
			{
				fprintf(stderr,"\n 点抄状态字 ");

				INT8U buf03001501[65] = {
						  0x68 ,0x41 ,0x00 ,0x81 ,0x04 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0a
						 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00 ,0x32 ,0x00 ,0x00 ,0x00
						 ,0x00 ,0x10 ,0x13 ,0x01 ,0x00 ,0x00 ,0x00 ,0x02 ,0x22 ,0xfe
						 ,0xfe ,0xfe ,0xfe ,0x68 ,0x24 ,0x02 ,0x00 ,0x00 ,0x00 ,0x00
						 ,0x68 ,0x91 ,0x12 ,0x34 ,0x48 ,0x33 ,0x37 ,0x33 ,0x33 ,0x33
						 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0x33 ,0xdd
						 ,0xdd ,0x9d ,0x16 ,0x77 ,0x16
									};
				memcpy(SendBuff,buf03001501,65);
				WriteLen = 65;
				step = 3;
			}


			if(WriteLen == 0 )
			{
				//AFN13-F01
				INT8U buf0102[21] = {
						0x68 ,0x15 ,0x00 ,0x81 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x0b ,
						0x00 ,0x01 ,0x00 ,0xff ,0xff ,0xff ,0xff ,0x00 ,0x00 ,0x89 ,
						0x16
									};
				memcpy(SendBuff,buf0102,21);
				WriteLen = 21;
				fprintf(stderr,"\n 13 01 未知回确认");
			}

		}
#endif
		if(WriteLen >0)
		{
			fprintf(stderr,"\nS[%d] ",WriteLen);

			for(i = 0;i < WriteLen;i++)
			{
				fprintf(stderr,"%02x ",SendBuff[i]);
			}
			fprintf(stderr,"\n");

			SendLen  = write(fd,SendBuff,WriteLen);

			fprintf(stderr,"-----SendLen = %d\n",SendLen);
		}
		fprintf(stderr,"\n\n\n\n---------------------------------\n\n");

		sleep(1);
	}
	return EXIT_SUCCESS;
}
